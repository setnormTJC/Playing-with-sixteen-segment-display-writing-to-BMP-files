#pragma once

#include<vector> 
#include<array> 

#include<memory>

#include<string> 

#include<iostream> 

#include<map> 

#include<set> //pieces will be unique (ex: white, queen side knight) 

#include<iomanip>

using std::vector;
using std::string;
using std::set;
using std::array;
using std::map;

using std::ostream;

using std::cout;

using std::setw;


struct ChessPosition
{
	int row = 0; //init to illegal positions (for now) 
	char column = 'Z'; //A, B, C, D, E, F, G, H

	bool operator == (const ChessPosition& otherPosition) const;


	bool operator < (const ChessPosition& other) const;

	friend std::ostream& operator << (ostream& os, const ChessPosition& chessPosition);

	ChessPosition() {};

	ChessPosition(char column, int row)
		:column(column), row(row)
	{

	}
};

class Piece
{
protected:
	//anticipating use of inheritance
 
public:
	string pieceName;

	Piece();
	Piece(string pieceName)
		:pieceName(pieceName)
	{

	}
	bool isLegalMove(const ChessPosition& positionToMoveFrom, const ChessPosition& positionToMoveTo);

	bool operator < (const Piece& otherPiece) const;
	friend std::ostream& operator << (ostream& os, const Piece& piece);

};



class Rook : public Piece
{
private:
public:
	Rook(string pieceName)
		:Piece(pieceName)
	{
		//add special attributes of knight here perhaps 
	}

	/*Should first apply basic move rules for piece (ex: any number of horiz/vertical moves for rook)
	* THen should remove from vector of moves if a piece of same color is "in the way" 
	* Add to point calculator (or set flag?) if piece of different color can be taken 
	* Handle avoiding checks later ...
	*/
	vector<ChessPosition> generateLegalMoves(const ChessPosition& startPos);
};

class Knight : public Piece
{
private:
public:
	Knight(string pieceName)
		:Piece(pieceName)
	{
		//add special attributes of knight here perhaps 
	}

	vector<ChessPosition> generateLegalMoves(const ChessPosition& startPos);
};

class Bishop : public Piece
{
private:
public:
	Bishop(string pieceName)
		:Piece(pieceName)
	{
		//add special attributes of knight here perhaps 
	}

	vector<ChessPosition> generateLegalMoves(const ChessPosition& startPos);
};

class Queen: public Piece
{
private:
public:
	Queen(string pieceName)
		:Piece(pieceName)
	{
		//add special attributes of knight here perhaps 
	}

	vector<ChessPosition> generateLegalMoves(const ChessPosition& startPos);
};

class King : public Piece
{
private:
public:
	King(string pieceName)
		:Piece(pieceName)
	{
		//add special attributes of knight here perhaps 
	}

	vector<ChessPosition> generateLegalMoves(const ChessPosition& startPos);
};

class Pawn : public Piece
{
private:
public:
	Pawn(string pieceName)
		:Piece(pieceName)
	{
		//add special attributes of knight here perhaps 
	}

	vector<ChessPosition> generateLegalMoves(const ChessPosition& startPos);
};


class ChessGame
{

	/*Use pointer to Piece for polymorphism?*/
	/*using set rather than vector because pieces might ought to be uniquely identifiable (including PAWNS)*/
	set<Piece> pieces;

	/*A ONE-dimensional array (NOT two)*/
	array<ChessPosition, 64> boardPositions; 

	/*Positions mapped to pieces (most positions will be empty)*/
	map<ChessPosition, Piece> theBoardState;

	/*private because perhaps only called by constructor*/
	void generateBoardPositions();
	
	/*"pieces" also includes PAWNS here*/
	void generatePieces(); 
	
	/*REQUIRES? that board positions and pieces have been generated by functions above
	Modifies `theBoardState` variable
	*/
	void initializeBoard();

public:

	/*Initializes board and then draws (and displays) it as an image file*/
	ChessGame()
	{
		generateBoardPositions(); 
		generatePieces();
		initializeBoard();

		drawBoard();
	}

	bool isValidMove(const Piece& piece, const ChessPosition& previousPosition, const ChessPosition& newPosition)
	{
		return true; //placeholder for very complicated logic ...
	}
	/*
	@param pieceName - ex: whiteQueenSideKnight
	@param newPosition - ex: A1, B3, etc.
	*/
	void movePiece(const Piece& piece, const ChessPosition& previousPosition, const ChessPosition& newPosition)
	{

		//call Piece's move method? 
		

		//update board if isValid 
		if (!isValidMove(piece, previousPosition, newPosition))
		{
			cout << piece << " not allowed to move to " << newPosition << "\n";
			return;
		}

		else
		{
			//auto previousPositionIterator = theBoard.find(previousPosition); 

			if (theBoardState.find(previousPosition) != theBoardState.end())
			{
				//remove piece from previous position by setting an "empty piece" there
				Piece emptyPiece;
				theBoardState.at(previousPosition) = emptyPiece;

				//move piece to new position: 
				//theBoard.at(newPosition) = 
				//theBoard[newPosition] = &pieceName;
			}

			else
			{
				cout << "Piece " << piece << " not found on board\n";
			}

		}

	};


	/*
	This should write a BMP image file
	*/
	void drawBoard()
	{

	}

};

